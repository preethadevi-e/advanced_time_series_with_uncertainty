# -*- coding: utf-8 -*-
"""advanced_time_series_with_uncertainty.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lG3YhVGUKBw1Lgu1B5lDnLWxZXZXyjWo
"""

"""
Advanced Time Series Forecasting with Uncertainty Quantification
Single-file, production-style implementation.

Author: Preetha Devi
"""

# =====================================================
# Imports
# =====================================================
import numpy as np
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from statsmodels.tsa.statespace.sarimax import SARIMAX
import tensorflow as tf

np.random.seed(42)
tf.random.set_seed(42)

# =====================================================
# data_prep
# =====================================================
def generate_multivariate_data(n_steps=1200):
    t = np.arange(n_steps)

    f1 = np.sin(0.02 * t) + np.random.normal(0, 0.1, n_steps)
    f2 = 0.7 * f1 + np.random.normal(0, 0.1, n_steps)
    f3 = np.cos(0.02 * t) + np.random.normal(0, 0.1, n_steps)

    target = 0.5 * f1 + 0.3 * f2 + 0.2 * f3 + np.random.normal(0, 0.05, n_steps)

    return pd.DataFrame({
        "f1": f1,
        "f2": f2,
        "f3": f3,
        "y": target
    })

def create_sequences(data, window=30, horizon=5):
    X, y = [], []
    for i in range(len(data) - window - horizon):
        X.append(data[i:i+window, :-1])
        y.append(data[i+window:i+window+horizon, -1])
    return np.array(X), np.array(y)

# =====================================================
# model_arch
# =====================================================
def build_lstm(window, n_features, horizon):
    model = Sequential([
        LSTM(64, return_sequences=True, input_shape=(window, n_features)),
        Dropout(0.3),
        LSTM(32),
        Dropout(0.3),
        Dense(horizon)
    ])
    model.compile(
        optimizer=Adam(learning_rate=0.001),
        loss="mse"
    )
    return model

def mc_dropout_predict(model, X, n_samples=100):
    predictions = []
    for _ in range(n_samples):
        predictions.append(model(X, training=True).numpy())
    return np.array(predictions)

# =====================================================
# baseline_models
# =====================================================
def fit_sarimax(train_series, steps):
    model = SARIMAX(train_series, order=(1,1,1))
    fitted = model.fit(disp=False)

    forecast = fitted.get_forecast(steps=steps)
    mean = forecast.predicted_mean
    ci_80 = forecast.conf_int(alpha=0.20)
    ci_95 = forecast.conf_int(alpha=0.05)

    return mean, ci_80, ci_95

# =====================================================
# evaluation
# =====================================================
def coverage_rate(y_true, lower, upper):
    return np.mean((y_true >= lower) & (y_true <= upper))

def interval_width(lower, upper):
    return np.mean(upper - lower)

# =====================================================
# main
# =====================================================
def main():

    # ----- Parameters -----
    WINDOW = 30
    HORIZON = 5
    TEST_SPLIT = 0.8

    # ----- Data -----
    data = generate_multivariate_data()
    scaler = MinMaxScaler()
    scaled = scaler.fit_transform(data)

    X, y = create_sequences(scaled, WINDOW, HORIZON)
    split = int(TEST_SPLIT * len(X))

    X_train, X_test = X[:split], X[split:]
    y_train, y_test = y[:split], y[split:]

    # ----- LSTM -----
    lstm = build_lstm(WINDOW, X.shape[2], HORIZON)
    lstm.fit(X_train, y_train, epochs=25, batch_size=32, verbose=0)

    # ----- Monte Carlo Dropout -----
    mc_preds = mc_dropout_predict(lstm, X_test, n_samples=200)
    mean_preds = mc_preds.mean(axis=0)

    lower_80 = np.percentile(mc_preds, 10, axis=0)
    upper_80 = np.percentile(mc_preds, 90, axis=0)
    lower_95 = np.percentile(mc_preds, 2.5, axis=0)
    upper_95 = np.percentile(mc_preds, 97.5, axis=0)

    # ----- Metrics (LSTM) -----
    rmse_lstm = np.sqrt(mean_squared_error(y_test.flatten(), mean_preds.flatten()))
    mae_lstm = mean_absolute_error(y_test.flatten(), mean_preds.flatten())

    cov_80_lstm = coverage_rate(y_test, lower_80, upper_80)
    cov_95_lstm = coverage_rate(y_test, lower_95, upper_95)

    width_80_lstm = interval_width(lower_80, upper_80)
    width_95_lstm = interval_width(lower_95, upper_95)

    # ----- SARIMAX Baseline -----
    sarimax_mean, sarimax_ci80, sarimax_ci95 = fit_sarimax(
        data["y"][:split + WINDOW],
        steps=len(y_test.flatten())
    )

    sarimax_lower_95 = sarimax_ci95.iloc[:, 0].values
    sarimax_upper_95 = sarimax_ci95.iloc[:, 1].values

    rmse_sarimax = np.sqrt(
        mean_squared_error(
            y_test.flatten()[:len(sarimax_mean)],
            sarimax_mean.values
        )
    )

    width_95_sarimax = interval_width(sarimax_lower_95, sarimax_upper_95)

    # ----- Results -----
    print("\n===== POINT FORECAST METRICS =====")
    print(f"LSTM   RMSE : {rmse_lstm:.4f}")
    print(f"LSTM   MAE  : {mae_lstm:.4f}")
    print(f"SARIMAX RMSE: {rmse_sarimax:.4f}")

    print("\n===== UNCERTAINTY METRICS =====")
    print(f"LSTM 80% Coverage : {cov_80_lstm:.3f}")
    print(f"LSTM 95% Coverage : {cov_95_lstm:.3f}")
    print(f"LSTM 80% Width    : {width_80_lstm:.4f}")
    print(f"LSTM 95% Width    : {width_95_lstm:.4f}")
    print(f"SARIMAX 95% Width : {width_95_sarimax:.4f}")

    print("\nNOTE:")
    print("SARIMAX provides analytically derived confidence intervals,")
    print("while LSTM uncertainty is approximated via Monte Carlo Dropout.")

# =====================================================
# entry point
# =====================================================
if __name__ == "__main__":
    main()
